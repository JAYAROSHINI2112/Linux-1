kamaldgrt@gmail.com
WHILE LOOP,for loop(entry controlled loop)

initialization of loop control variable
while(expression)
{

//statements
//updation of loop control variable
}

------------------------------------------
for(init of loop controlvariable;expression;updation)
{

//statements
}

----------------------------
do while loop(exit controlled loop)
initialization of loop control variable
do{
//statements
//updation of loop control variable
}while(expression);

FINITE LOOPS

i expected finite loop but i got infinte loop---desired otput???

INFINITE LOOPS???

while(nonzero)   //5   //-6
{


}

for(;;)
{


}

nested loops:

One loop inside another loop:

for(i=0;i<5;i++)
{
	printf("in outer loop:%d\n",i);
	for(j=0;j<5;j++)
		printf("in outer loop:%d\n",j);
}

//FOR EVERY ITERATION OF OUTER LOOP,INNER LOOP STARTS AND ENDS THE LOOP.....

MATRIX

_________________________________________________

int a,b,c,d;

int arr[5];  //declaration 
//memory it takes

printf("sizeof of an array:%d\n",sizeof(arr));  elements*memory occupied for storing single data...

int arr[]={1,2,3,4,5};
int arr[5]={1,23};  //partially initialization of array
int arr[];  //not allowed

//read array from std inpt device keyboard....

scanf("%d",&arr[0]);

scanf("%d",&arr[1]);

scanf("%d",&arr[0]);


scanf("%d",&arr[0]);

---------------------------------------------------------------------------
int i=0;
for(i=0;i<sizeof(arr)/sizeof(int);i++)
{
	scanf("%d",&arr[i]);
	printf("arr[%d]=%d\n",i,arr[i]);
}
________________________________________________________________

float,double......
float arr_f[]={1.2,3.45,78.9};

printf("%d\n",sizeof(arr_f));   //N*sizeof(arraytype)--->3*4bytes=12 bytes.....
________________________________________________________________________

CHARACTER ARRAY:

char str[]={'a','e','y','\0'};   		NUL,NULL ASCII

4 characters....
a  00
b  01
c  10
d  11

2bits
char str[]="hello";
char str[5]="gty";
--------------------------------------------------
reading the string from keyboard:

char str[10];
printf("enter the i/p string:\n");
scanf("%s",str);
----------------------------------------------------------

What ever might be the type of array u are working with
ARRAY NAME implies BASE ADDRESS (address of starting element address).......

scanf("%s",str);
because for strings alone a specific format specifier available that is %s
----------------------------------------------------------------------------------------------------------
int main()   {

int i=0;
char str[10];
printf("enter the string:\n");
scanf("%s",str);
while(str[i]!='\0')   {
	printf("%c\n",str[i]);
	i++;
}

printf("%s\n",str);   //printing strings in one shot......using %s specifier
return 0;
}
----------------------------------------------------------------------------------------------------------------------------
POINTERS:

Is a variable which stores address as its content.....
pointer variable,constant pointer '
const type qualifier.....


datatype* ptr_name;

int*ptr_i=NULL;   //NUL   NULL----> (Void*)0
int a=765;
int*ptr_i=&a;
{
int i;
int*ptr;
printf("i=%d\n",i);
printf("%d\n",*ptr);

}
		WILD POINTER.....

single pointer
DOUBLE POINTER
TRIPLE POINTER
FUNCTION POINTER(ARRAY)
STRUCTURE POINTER
ARRAY OF POINTERS(INT,CHAR,FLOAT,STRUCTURE)
POINTER TO AN ARRAY
GENERIC POINTER
_______________________________________

int a=100,*sp=&a,**dp=&sp;
//accesing value of a through a
printf("%d\n",a);
//accesing value of a through sp
printf("%d\n",*sp);
printf("address of a=%p\t%p\t%p\n",&a,sp,*dp);
//accessing value of dp through 
printf("%p\t%p\n",&sp,dp);

-------------------------------------------------------------------------------------------------------

Arrays and pointers
int main()  {

int a;    //4bytes

//point




int arr[]={1,2,3,4,5},i,*p_a=arr;

//arr is ARRAY NAME base address (starting element address)
pointer arithmetic operation to access next next element of array

for(i=0;i<sizeof(arr)/sizeof(int);i++)  {
	printf("%d\n",*(p_a+i));   //p_a[i]
	printf("%d\n",arr[i],*(arr+i),*(i+arr));
}


*(p_a+i)

*(1000+0)--->*1000
*(1000+1)---->*1004
---------------------------------------------------------------------------------
character array related library functions.......

strlen,strcpy,strcmp,strcat,strstr

string operations
char str[]="goodmorning";
int i=0,len=0;

while(str[i++]!='\0')
	len++;   //len=len+1;
printf("length of string%s is %d\n",str,len);
-------------------------------------------------------------
hello
Hello
__________________________________________________________
2d array:
------------------------------------------------------------------------------
#define ROW 2
             COL 2
int a_2d[2][2]={{1,2},{3,4}};
int a_2d[2][2]={1,2,3,4};
int a_2d[][2]={1,2,3,4};
int i=0,j=0;

for(i=0;i<2;i++)
{
	for(j=0;j<2;j++)
		printf("%d\t%d\n",a_2d[i][j],&a_2d[i][j]);
		
}
1000 1004 1008 1012,..........
---------------------------------------------------------------
a_2d[i][j]----->*(*(a_2d+i)+j)

a_3d[i][j][k]----->*(*(*(a3d+i)+j)+k)
--------------------------------------------------------------
STRINGS:

char atr[]="hi";
atr[0]='u';

char *str="qwerty";
*str='y';//  error
___________________________
STRING RELATED OPERATIONS:
strcpy

char src[]="goodmorning";
char dst[15];
int i=0;
while(src[i++]!='\0')
	dst[i]=src[i];
dst[i]='\0';

printf("%s\n",dst);
-------------------------------------------
SINGLE DIMENSIONAL--->REFER USING POINTERS?pointer to an integer
int arr[]={1,2,3,4};     int*p;
char str[]="hello";     char *sptr;
float farr[]={1.2,3.56,6.78};     float *fptr;

in general multidimensional array should also be accessed by POINTERS......

POINTER TO AN ARRAY  

int a2d[2][2]={1,2,3,4};
int *p;  POINTER TO AN INTEGER....
int *p[2];  //ARRAY OFPOINTERS TO INTEGERS

int(*pa)[t];    POINTER TO AN ARRAY.....
t--->signifies column alone....

int arr[2][2];
int(*pa)[2];

int arr[2][3];
int(*pa)[3];
-----------------------------------------------

Pointer to a built in datatype        Pointer to an array

*Memory occupied		  same reason
(based on the machine 
on which it operates)
32 bit -4bytes...

Pointer arithmetic operations      It is strictly based on the 
Strictly based on                           number of elements what  
type of data to which                    complete array holds
it points to
__________________________________________________

Generic pointer

void*gptr;
int a=100,*pi=&a;
gptr=&a;
char c='r',*pc;
printf("pi=%d\tgptr=%d\n",*pi,*(int*)gptr);
gptr=&c;
printf("pc=%c\tgptr=%c\n",*pc,*(char*)gptr);
_______________________________________________
2darray
arr
*arr
*(arr+i)
(*(arr+i)
(*(arr+i)+j);
*(*(arr+i)+j)
_________________________________________________
Functions:

set/group of statements intended to do some task.....
----------------------------------------------------------
#include<stdio.h>
void sum(int,int);   //function prototype /declaration
int main()  {

sum(10,20);
return 0;
}

void sum(int a,int b)
{
	printf("sum=%d\n",sum);
}
---------------------------------------------------
1.function with return type and with arguments...
2.function with return type and without arguments
3.function without return type and with arguments
4.function with return type and without arguments.....

------------------------------------------------------------------
FUNCTION CALL OVERHEAD

Application code/program....
memory allocated 

divided into number of segments...
STACK,CODE,DATA,HEAP.....

FACTORIAL

BASE CASE
STACK OVERFLOW
--------------------------------------------------------------
#inclde<stdio.h>
int fact_num(int);

int main()  {
	int fact_res,num;
	printf("enter the number:\n");
	scanf("%d",&num);
	fact_res=fact_num(num);
	printf("factorial of %d is %d\n",num,fact_res);
	return 0;
}

int fact_num(int a)
{
	int res;
	if((a==0)||(a==1))
		return 1;
	else
	{
		res=a*fact_num(a-1);
		return res;
	}
}

-------------------------------------------------------------------------
STORAGE CLASS SPECIFIERS.....

1.AUTO:	is applied for local variable only
2.REGISTER:	is applied for local variable only
3.STATIC:	is applied for local/global variable only
4.EXTERN:	is applied for global variable only

SEGMENT:	STACK,DATA
DEFAULT VALUE:	0/GARBAGE VALUE
LIFETIME:	throughout program execution/within the block
SCOPE: 	where and all it can be referred
LINKAGE:		internal/external/NO


Local variable:

int main()  {

	int l;
	{
		int a;
	}
}
GLOBAL: 
int g;
int main()  {

	auto int l;
	{
		auto int a;
	}
}
------------------------------------------------------------
By default for a local variable auto storage class specifier is applied.
SEGMENT:	STACK
DEFAULT VALUE:	GARBAGE VALUE
LIFETIME:	within the block
SCOPE: 	local to the block where it is declared.
LINKAGE:		NO

Register storage class :
register int i;
for(i=0;i<10;i++)

In case of register storage class variable may or may not be stored in CPU registers why because availability of CPU registers are minimal......

SEGMENT:	cpu registers
DEFAULT VALUE:	GARBAGE VALUE
LIFETIME:	within the block
SCOPE: 	local to the block where it is declared.
LINKAGE:		NO
------------------------------------------------
STATIC APPLIED FOR lOCAL VARIABLE 
-will help to retain values in between a function call....

STATIC GLOBAL:
SEGMENT:	DATA segment
DEFAULT VALUE:	0
LIFETIME:	Throughot the program execution
SCOPE: 	Any where in that particlar file
LINKAGE:		INTERNAL
------------------------------------------------------------------

EXTERN GLOBAL:
SEGMENT:	DATA segment
DEFAULT VALUE:	0
LIFETIME:	Throughout the program execution
SCOPE: 	Any where in the files which are compiled together
LINKAGE:		EXTERNAL
-----------------------------------------------------------
STATIC AND EXTERN STORAGE CLASS SPECIFIERS CAN BE 
APPLIED FOR FUNCTIONS AS WELL.....

MEMORY ALLOCATION

STATIC   -->MEM ALLOCATION DuRING COMPILE TIME
DYNAMIC ->>>>>RUN TIME

dynamic---->time higher,memory will be efiiciently utilized.........
static:fixed,lesses time,but memory is not efficiently utilized.....
{
int a;
int arr[10];
float f_arr[10];



//at this point 


}
----------------------------------------------------------------------
Dynamic memory allocation:
malloc,calloc,realloc,free.....
malloc--allocates memory...
free---deallocates memory....


int*ptr=(int*)malloc(sizeof(int));
	or
int*ptr=(int*)malloc(4);



free(ptr);
printf("%p\n",ptr);  //trying to access the memory address to which ptr is pointing to.... why because even though memory is released ptr still holds the address.... to which it was pointing at....

THIS PROBLEM IS KNOWN AS "DANGLING POINTER".
SOLUTION: After deallocating the memory using free immediately assign NULL to ptr.....

free(ptr);
ptr=NULL;

"DANGLING POINTER"--->POINTER POINTING TO A MEMORY WHICH IS RELEASED USING FREE LIB FUNCTION.......
-----------------------------------------------------------------------------------
WILD POINTER:
uninitialized pointer.....
int*ptr;
printf("%d\n",*ptr);
---------------------------------------------------------------------------------
MEMORY LEAK

fAILING TO DEALLOCATE THE MEMORY WHICH IS ALLOCATED......

SOLUTION VALGRIND...................
--------------------------------------------------------------------------------------
int*p_a=(int*)malloc(sizeof(int)*5);
int i;
printf("enter the elements for array:\n");
for(i=0;i<5;i++)
{
	scanf("%d",p_a);
	printf("*p_a=%d\n",*(p_a+i));    //p_a[i]
}
return 0;
}
calloc,realloc,.......

How to allocate memory for 2d array????
pointer to an int
array of pointers to ints
POINTER TO AN ARRAY.....
--------------------------------------------------------------------------------------
next topic.......?

Structures:USER DEFINED DATATYPE....

DATATYPES:
	BUILTIN TYPES
	DERIVED TYPES....
-------------------------------------------------------
INT,CHAR,FLOAT,DOUBLE,........

STRUCTURE:
	COLLECTION OF N NUMBER OF DATA MEMBERS....

syntax:

	struct structure_name   {
	//DATA MEMBERS


	};
HOW MUCH MEMORY DOES A STRUCTURE TAKES......

---SUM OF MEMORY OCCUPIED BY ITS DATAMEMBERS......

Session agenda 
functions wrt pointers,structures,arrays,array of function pointers
structre pointers,structure padding,.......

PREPROCESSOR DIRECTIVES........

Functionpointer

void fun();
void fun2();

void (*fp)()=fun;   //function pointer declaration

void (*fpp)();
fpp=fun2;

//array of function pointers
int add(int,int);
int sub(int,int);
int mul(int,int);
int (*fp[])(int,int)={add,sub,mul};

int(*fp[])(int,int);
int arr[];
-------------------------------------------------

struct emp
{
	char name[10];
	int eid;
	float sal;
}e2={"rahul",56789,6785.3},*sptr;

//TYPEDEF
typedef struct emp
{
	char name[10];
	int eid;
	float sal;
}EMP;

int main()
{
	struct emp e1,*sp=&e1;
	printf("enter the data:\n");
	scanf("%s%d%f",e1.name,&(e1.eid),&(e1.sal));
	struct emp e3={  };
	//STRUCTURE POINTERS
	printf("printing structure data members using structure pointer variable:\n");
	printf("%s\t%d\t%f\n",sp->name,sp->eid,sp->sal);
	//DMA for structures

	//int*p_i=(int*)malloc(sizeof(int));

	struct emp*st_ptr=(struct emp*)malloc(sizeof(struct emp));
	//applying new name throgh typedef
	EMP*st_ptr=(EMP*)malloc(sizeof(EMP));
	printf("sizeof structure=%d\n",sizeof(EMP));
	
}
To restrict padding
#pragma pack(1)

Nesting of structures....
struct dob
{
	int date;
	int month;
	int year;
};

struct student
{
	char name[10];
	int age;
	struct dob d1;
}s1;

s1.d1.date


kamaldgrt@gmail.com

Union,enum,preprocessor directives,LINKED LIST,trees,search,sort,command line args,
variable number of arguments,Files...

-------------------------------------------------------------------------------------

Linked list:  1.Linear Data structures...
	  2.Nonlinear Data structures....

SLL,DLL,CLL
Stack,Queue

Trees

------------------------------------------------------------------
Linked list
SLL(Single linked list...)

Basic set of operations:

1.Addition of node at beginning,desired position,end.....
2.Deletion of node at beginning,desired position,end.....
3.Traversal of the linked list
4.Display
5.Miscelleanous (search(query),sort,split the list,merge.....)
-------------------------------------------------------------------------------
Structures 

struct emp
{
	char name[10];
	int eid;
	struct emp e1;
};

struct emp
{
	char name[10];
	int eid;
	struct emp *eptr;
};

SELF REFERENTIAL STRUCTURES....

DATASTRUCTURES:
ARRAYS...

struct node
{
	int data;
	struct node*link;
};

struct emp
{
	char name[10];
	int eid;
	float sal;
	struct emp*link;
};
------------------------------------------------------------------------------------------
Linked list will have HEAD pointer which points to the first node of the Linked list....

typedef struct sll
{
	int data;
	struct sll*link;
}SLL;

int main()
{
	int del_item;
	SLL*head=NULL,*newnode;
	newnode=create_node(100);
	addatend(&newnode,&head);
	newnode=create_node(200);
	addatbeg(&newnode,&head);
	newnode=create_node(300);
	addatpos(&newnode,&head);
	del_item=delatbeg(&head);
	if(del_item ==-1)
		printf("list is empty cannot perform delete operation:\n");
	else
		printf("data deleted from the list is %d\n",del_item);		
}

SLL*  create_node(int d)
{
	  
	SLL*newnode=malloc(sizeof(SLL));
	if(newnode==NULL)
	{
		printf("memalloc failed:\n");
		exit(0);
	}
	else
	{
		newnode->data=10
		newnode->link=NULL;
		
	}
}	

void addatend(SLL** n,SLL**h)
{
	SLL*currptr=NULL;
	if(*h==NULL)
	{
		printf("list is empty:\n");
		*h=*n;
		return;
	}
	else
	{
		currptr=*h;
		while(currptr->link!=NULL)
			currptr=currptr->link;
		currptr->link=*n;
	}
}

void addatbeg(SLL**n,SLL**h)
{
	if(*h==NULL)
	{
		printf("LIST IS EMPTY:\n");
		*h=*n;
		return;
	}
	else	
	{
		(*n)->link=*h;
		*h=*n;
		return;
	}
}

void addatpos(SLL**n,SLL*h)
{
	SLL*currptr=*h;
	int pos,i,count=0;
	if(*h==NULL)
	{
		printf("list is empty cannot add node at desired position:\n");
		return;
	}
	else
	{
		printf("enter the desired position:\n");
		scanf("%d",&pos);
		while(currptr->link!=NULL)
		{
			currptr=currptr->link;
			count++;
		}
		if(pos>count)
		{
			printf("entered pos is invalid cannot add node at pos:\n");
			return;
		}
		//3nodes pos=2
		currptr=*h;
		for(i=1;i<=pos-1;i++)
			currptr=currptr->link;
		(*n)->link=currptr->link;
		currptr->link=*n;
	}
}

int delatbeg(SLL**h)
{
	int dtb;
	SLL*currptr=*h;
	if(*h==NULL)
	{
		printf("list is empty:\n");
		return -1;	
	}
	else
	{
		*h=currptr->link;
		dtb=currptr->data;
		free(currptr);
		currptr=NULL;
		return dtb;
	}
}

int delatpos(SLL**h)					
{
	int pos,i=1,count=0;
	SLL*prevptr;
	if(*h==NULL)
	{
		printf("list is empty cannot delete node at pos:\n");
		return -1;
	}
	else
	{
		printf("enter pos:\n");
		scanf("%d",&pos);
		while(currptr->link!=NULL)
		{
			count++;
			currptr=currptr->link;
		}
		if(pos>count)
		{
			printf("entered pos is invalid cannot delete at pos count=%d and pos=%d\n",count,pos);
			return -1;
		}
		else
		{
			currptr=*h;
			for(i=1;i<=pos-1;i++)
			{
				prevptr=currptr;
				currptr=currptr->link;
			}
			//5nodes pos=3
			dtb=currptr->link;
			prevptr->link=currptr->link;
			free(currptr);
			currptr=NULL;
			return dtb;
		}
	}
}


*************************************************************************************************************

DLL Double linked list....


typedef struct dll
{

	struct dll*plink;
	int data;
	struct dll*nlink;
}DLL;


plink---->points to previous node address
nlink points to next node address.....

*************************************************************************************************

void addatbeg(DLL**,DLL**);
DLL* create_node(DLL**,int);

int main() 
{

	DLL*head=NULL,*newnode;
	newnode=create_node(head,100);
	addatbeg(&newnode,&head);





}



void addatbeg(DLL**n,DLL**h)
{
		if(*h==NULL)
		{
			printf("LIST IS EMPTY:\n");
			*h=*n;
			return;
		}
		else
		{
			currptr=*h;
			(*n)->nlink=currptr;
			*h=*n;
			currptr->plink=*n;
		}
}		


_____________________________________________________________________________________

STACK AND QUEUE.....

Stack--->
Top-->points to topmost node in the datastructure....


_-------------------------------------------------------------------------------------------------------------

PUSH
POP

----------------------------------------------------------------------------------------------------------------

QUEUE

FIFO
front,rear



#define QUEUE_SIZE 10
#include<stdio.h>
int count=0;

typedef struct myqueue
{
		int data;
		struct myqueue*link;
}MYQUEUE;

MYQUEUE create_node(MYQUEUE**,MYQUEUE**,int);
void addnode(MYQUEUE**,MYQUEUE**,MYQUEUE**);

int main()
{
	MYQUEUE*front=NULL,*rear=NULL,*newnode=NULL;
	newnode=create_node(&front,&rear,100);
	addnode(&newnode,&front,&rear);
	

}

MYQUEUE* create_node(MYQUEUE**f,MYQUEUE**r,int d)
{
		MYQUEUE*newnode=(MYQUEUE*)malloc(sizeof(MYQUEUE));
		if(newnode==NULL)
		{
			printf("memalloc failed:\n");
			exit(0);
		}

		else
		{
			newnode->data=d;
			newnode->link=NULL;
		}
}
							
--------------------------------------------------------------------------------------------------------------------------


void addnode(MYQUEUE**n,MYQUEUE**f,MYQUEUE**r)
{
	if(*f==*r==NULL)
	{
		printf("QUEUE is Empty:\n");
		*f=*r=*n;
		return;
	}
	else
	{
		(*r)->link=*n;
		*r=*n;
		return;
	}
}

-------------------------------------------------------------------------------------------------------------------
Datastructures   	LINEAR DS

Non linear DS

Trees-->Binary search tree

	
11,78,12,34,67,89,23,56.....


LINKED LIST...


typedef struct sll
{
	int data;
	struct sll*link;
}SLL;


Real word application:

typedef struct mystruct
{
	char ename[10];
	int eid;
	float sal;
	struct mystruct *nlink;
}EMP;
